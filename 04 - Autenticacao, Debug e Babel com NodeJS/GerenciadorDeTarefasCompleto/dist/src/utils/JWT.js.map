{"version":3,"sources":["../../../src/utils/JWT.js"],"names":["SECRET_KEY","checkTokenMiddleware","req","res","next","token","headers","cookies","checkToken","then","decodedToken","decoded","catch","console","error","ex","status","send","Promise","resolve","reject","verify","err","generateToken","usuario","senha","sign","encoding"],"mappings":";;;;;;;AAAA;;;;;;AAEA;AACA,IAAMA,aAAa,2DAAnB;;AAEA;;;;;;;AAOO,IAAMC,sDAAuB,SAAvBA,oBAAuB,CAACC,GAAD,EAAMC,GAAN,EAAWC,IAAX,EAAoB;AACpD,QAAMC,QAAQH,IAAII,OAAJ,CAAY,gBAAZ,KAAiCJ,IAAIK,OAAJ,CAAY,gBAAZ,CAA/C;AACAC,eAAWH,KAAX,EACKI,IADL,CACU,mBAAW;AACbP,YAAIQ,YAAJ,GAAmBC,OAAnB;AACAP;AACH,KAJL,EAIOQ,KAJP,CAIa,cAAM;AACXC,gBAAQC,KAAR,CAAc,uCAAd,EAAuDT,KAAvD,EAA8DU,EAA9D;AACAZ,YAAIa,MAAJ,CAAW,GAAX,EAAgBC,IAAhB;AACH,KAPL;AAQH,CAVM;;AAYP;;;;;;AAMO,IAAMT,kCAAa,SAAbA,UAAa,CAACH,KAAD,EAAW;AACjC,WAAO,IAAIa,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACpC,+BAAIC,MAAJ,CAAWhB,KAAX,EAAkBL,UAAlB,EAA8B,UAACsB,GAAD,EAAMX,OAAN,EAAkB;AAC5C,gBAAIW,GAAJ,EAAS;AACLF,uBAAOE,GAAP;AACA;AACH;AACDH,oBAAQR,OAAR;AACH,SAND;AAOH,KARM,CAAP;AASH,CAVM;;AAYP;;;;;;AAMO,IAAMY,wCAAgB,SAAhBA,aAAgB,CAACC,OAAD,EAAa;AACtC,WAAOA,QAAQC,KAAf;;AAEA,QAAIpB,QAAQ,uBAAIqB,IAAJ,CAASF,OAAT,EAAkBxB,UAAlB,EAA8B,EAAE2B,UAAU,MAAZ,EAA9B,CAAZ;;AAEA,WAAOtB,KAAP;AACH,CANM","file":"JWT.js","sourcesContent":["import jwt from \"jsonwebtoken\";\n\n// Substitua este valor por sua chave segura\nconst SECRET_KEY = \"chave secreta que assina e valida o token de autenticação\";\n\n/**\n * Middleware que verifica a validade e decodifica o token de autenticação presente no header 'x-access-token'.\n * \n * @param {request} req\n * @param {response} res\n * @param {next} next\n */\nexport const checkTokenMiddleware = (req, res, next) => {\n    const token = req.headers[\"x-access-token\"] || req.cookies[\"x-access-token\"];\n    checkToken(token)\n        .then(decoded => {\n            req.decodedToken = decoded;\n            next();\n        }).catch(ex => {\n            console.error('Não foi possível decodificar o token:', token, ex);\n            res.status(401).send();\n        });\n}\n\n/**\n * Valida a autenticidade e decodifica o token.\n * \n * @param {string} token\n * @return {Promise} \n */\nexport const checkToken = (token) => {\n    return new Promise((resolve, reject) => {\n        jwt.verify(token, SECRET_KEY, (err, decoded) => {\n            if (err) {\n                reject(err);\n                return;\n            }\n            resolve(decoded);\n        });\n    })\n}\n\n/**\n * Gera o token de autenticação para o usuário.\n * \n * @param {object} usuario objeto plano contendo os dados do usuário.\n * @return {string} Token de autenticação.\n */\nexport const generateToken = (usuario) => {\n    delete usuario.senha;\n    \n    let token = jwt.sign(usuario, SECRET_KEY, { encoding: 'UTF8' });\n\n    return token;\n}\n"]}